#!/usr/bin/env python
# -*- coding: utf-8 -*-
from io import TextIOWrapper
from os import environ as os_environ, pathsep as os_pathsep, getcwd as os_getcwd
from pathlib import Path
from subprocess import run as subprocess_run, CalledProcessError
from sys import argv as sys_argv, stderr as sys_stderr, stdin as sys_stdin, stdout as sys_stdout
from textwrap import dedent
from typing import Final, TypeVar, Any

try:
    from tomli import load as tomli_load
except ImportError:
    print("tomli is required (run `poetry install --no-root` or `poetry update`)", file=sys_stderr)

# CONSTANTS
# - project
PROJECT_PATH: Final[Path] = Path(__file__).parent.absolute()

# - pyproject file consts
PROJECT_TOML_FILE_PATH: Final[str] = PROJECT_PATH.joinpath('pyproject.toml').as_posix()
PROJECT_SECTION: Final[str] = 'tool.poetry'
STRUCTURE_OPTION: Final[str] = 'packages'

# - sources / test default paths
DEFAULT_DIST_PATH: Final[str] = 'dist'


# CLASSES
# - Project Configuration class
class ProjectProperties:
    T = TypeVar('T')

    def __init__(
            self,
            project_path: Path = PROJECT_PATH,
            toml_file_path: str = PROJECT_TOML_FILE_PATH,
            project_section: str = PROJECT_SECTION,
            structure_option: str = STRUCTURE_OPTION
    ):
        self.__toml_file_path: Final[str] = toml_file_path
        self.__project_section: Final[str] = project_section
        self.__structure_option: Final[str] = structure_option
        self.__toml_file_content: Final[dict[str, Any]] = self._load_toml()

        # - Global
        self.project_path: Final[Path] = project_path
        self.dist_path: Final[str] = DEFAULT_DIST_PATH
        self.src_rsrc_paths: Final[list[str]] = self._get_sources_and_resources_paths()

    def _load_toml(self) -> dict[str, Any]:
        with open(self.__toml_file_path, "rb") as toml_file:
            return tomli_load(toml_file)

    def _get_option(self, section: str, option: str, default: T | None = None) -> T | None:
        option_path: list[str] = section.split('.')
        path_dict: Any = self.__toml_file_content
        for path in option_path:
            path_dict = path_dict.get(path)
            if not (path_dict and isinstance(path_dict, dict)):
                return default
        return path_dict.get(option, default)

    def _get_sources_and_resources_paths(self) -> list[str]:
        return [
            self.project_path.joinpath(pkg_cnf['from']).as_posix()
            for pkg_cnf in self._get_option(self.__project_section, self.__structure_option, default=[])
            if 'from' in pkg_cnf
        ]


# - Project commands abstract class
class ProjectCommand:
    """The ProjectCommand abstract class used to execute a new project command"""

    def __init__(self):
        pass

    # noinspection PyMethodMayBeStatic
    def get_command_cwd(self, properties: ProjectProperties) -> str:
        """
        Define the command cwd (by default it is the project path)
        :param properties: the project properties
        :return: the command line cwd
        """
        return properties.project_path.as_posix()

    def build_command_line(self, properties: ProjectProperties, args: list[str] | None = None) -> list[str]:
        """
        Build the command line to execute
        :param properties: the project properties
        :param args: the given argument list to use. Parse it with an ArgumentParser if necessary
        :return: the command argv list (ie sys.argv)
        """
        raise RuntimeError("abstract method -- subclass %s must override" % self.__class__)


# -- Clean Command
class CleanCommand(ProjectCommand):
    """Remove directories generated by the "build" commands (like 'sdist' or 'wheel')"""

    def build_command_line(self, properties: ProjectProperties, args: list[str] | None = None) -> list[str]:
        clean_script: Final[str] = dedent(f"""\
        from shutil import rmtree
        from pathlib import Path

        def rmdir_if_exists(dir_path: Path) -> None:
            if dir_path.is_dir():
                print(" |- Remove %s directory" % dir_path)
                rmtree(dir_path)

        rmdir_if_exists(Path('{properties.dist_path}'))
        for path in Path('.').rglob('.pytest_cache'):
            rmdir_if_exists(path)
        """)
        command_line: Final[list[str]] = ['poetry', 'run', 'python', '-c', clean_script]
        if args:
            command_line.extend(args)
        return command_line


# -- Run Command
class RunCommand(ProjectCommand):
    """Run module which can be in the Maven Standard Directory Layout tree without having to configure the PYTHONPATH"""

    def build_command_line(self, properties: ProjectProperties, args: list[str] | None = None) -> list[str]:
        # Use a subprocess in order to be in the good cwd in the poetry venv
        # It is useful when you call project.py from an outside directory
        run_script: Final[str] = dedent(f"""\
        from subprocess import run
        from sys import stdin, stdout, stderr, executable
        run(
            [executable, {str(args or '').strip('[]')}],
            stdin=stdin,
            stdout=stdout,
            stderr=stderr,
            check=True,
            cwd="{os_getcwd()}")
        """)
        command_line: Final[list[str]] = ['poetry', 'run', 'python', '-c', run_script]
        return command_line


# -- Test Command
class TestCommand(ProjectCommand):
    """Run configured unit tests"""

    def build_command_line(self, properties: ProjectProperties, args: list[str] | None = None) -> list[str]:
        command_line: Final[list[str]] = ['poetry', 'run', 'pytest']
        if args:
            command_line.extend(args)
        return command_line


# -- Wheel Command
class WheelCommand(ProjectCommand):
    """Build Wheel archive into the configured 'dist_path' and using the configured 'build_path'"""

    def build_command_line(self, properties: ProjectProperties, args: list[str] | None = None) -> list[str]:
        command_line: Final[list[str]] = ['poetry', 'build', '--format', 'wheel']
        if args:
            command_line.extend(args)
        return command_line


# -- Sdist Command
class SdistCommand(ProjectCommand):
    """Build sdist archive into the configured 'dist_path'"""

    def build_command_line(self, properties: ProjectProperties, args: list[str] | None = None) -> list[str]:
        command_line: Final[list[str]] = ['poetry', 'build', '--format', 'sdist']
        if args:
            command_line.extend(args)
        return command_line


# -- Upload Command
class UploadCommand(ProjectCommand):
    """Upload available deliveries from the configured 'dist_path'"""

    def build_command_line(self, properties: ProjectProperties, args: list[str] | None = None) -> list[str]:
        command_line: Final[list[str]] = ['poetry', 'publish']
        if args:
            command_line.extend(args)
        return command_line


# - Project command executor class
TCommandsRunner = TypeVar("TCommandsRunner", bound="CommandsRunner")


class CommandsRunner:
    def __init__(
            self,
            properties: ProjectProperties,
            stdin: TextIOWrapper = sys_stdin,
            stdout: TextIOWrapper = sys_stdout,
            stderr: TextIOWrapper = sys_stderr
    ):
        self.__project_properties: Final[ProjectProperties] = properties
        self.__stdin: Final[TextIOWrapper] = stdin
        self.__stdout: Final[TextIOWrapper] = stdout
        self.__stderr: Final[TextIOWrapper] = stderr
        self.__command_dict: Final[dict[str, ProjectCommand]] = {}

    def add_command(self, cmd_name: str, cmd: ProjectCommand) -> TCommandsRunner:
        self.__command_dict[cmd_name] = cmd
        return self

    def run(self) -> None:
        if sys_argv and len(sys_argv) > 1:
            argv: str = sys_argv[1]
            if argv == "--help" or argv == "-h":
                print(self._get_help_str(), file=self.__stdout)
                return

            current_cmd: ProjectCommand | None = self.__command_dict.get(argv)
            if not self.__command_dict.get(argv):
                print(f"Command unknown: '{argv}'", file=self.__stderr)
                return
            else:
                current_args: list[str] = []
                for argv in sys_argv[2:]:
                    cmd: ProjectCommand | None = self.__command_dict.get(argv)
                    if cmd:
                        self._run_process(current_cmd, current_args)
                        current_args.clear()
                        current_cmd = cmd
                    else:
                        current_args.append(argv)
                self._run_process(current_cmd, current_args)
        else:
            print("Project command missing use --help or -h for help", file=self.__stderr)

    def _run_process(self, command: ProjectCommand, args: list[str]) -> None:
        try:
            subprocess_run(
                command.build_command_line(self.__project_properties, args),
                stdin=self.__stdin,
                stdout=self.__stdout,
                stderr=self.__stderr,
                check=True,
                cwd=command.get_command_cwd(self.__project_properties)
            )
        except CalledProcessError as e:
            print("Command error: [cmd: '%s' | args: '%s']" % (command.__class__.__name__, args), file=self.__stderr)
            exit(e.returncode)

    def _get_help_str(self):
        return "PROJECT COMMANDS WRAPPER:\n\n" \
               "Usage: python project.py <COMMAND_1> <arg1_1 ...> ... <COMMAND_N> <argN_1 ...>\n" \
               "\tNote: In order to get the wrapped command help, you can try python project.py <command> --help\n\n" \
               "Available commands are:\n" \
               + ''.join([f"  {cmd}    \t{cls.__doc__}\n" for cmd, cls in self.__command_dict.items()])


# FUNCTIONS
def run(properties: ProjectProperties) -> None:
    """"Execute given commands (from sys.argv) with the configured project structure in the PYTHONPATH"""
    # Configure CommandsRunner
    command_runner: Final[CommandsRunner] = CommandsRunner(properties=properties) \
        .add_command('clean', CleanCommand()) \
        .add_command('run', RunCommand()) \
        .add_command('test', TestCommand()) \
        .add_command('wheel', WheelCommand()) \
        .add_command('sdist', SdistCommand()) \
        .add_command('upload', UploadCommand())

    # Prepare PYTHONPATH
    project_paths: Final[list[str]] = properties.src_rsrc_paths
    pythonpath_env_var: Final[str] = 'PYTHONPATH'
    pythonpath: Final[str] = os_environ.get(pythonpath_env_var)
    if pythonpath:
        project_paths.append(pythonpath)

    # Run commands with project structure in the PYTHONPATH
    try:
        os_environ[pythonpath_env_var] = os_pathsep.join(project_paths)
        command_runner.run()
    finally:
        if pythonpath:
            os_environ[pythonpath_env_var] = pythonpath
        else:
            os_environ.pop(pythonpath_env_var, None)


# SHARED VARIABLES
project_properties = ProjectProperties()

# MAIN
if __name__ == '__main__':
    run(project_properties)
