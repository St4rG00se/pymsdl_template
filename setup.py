from pathlib import Path
from runpy import run_module, run_path
from shutil import rmtree
from sys import version as py_version, stderr as sys_stderr, argv as sys_argv
from typing import Final, Type
from unittest import TestSuite, TextTestRunner, defaultTestLoader

from setuptools import setup, find_namespace_packages, Command
from setuptools.errors import DistutilsError, OptionError

from project import project_properties


# SETUP FUNCTIONS
def read_file(file_path: str) -> str:
    with open(project_properties.project_path.joinpath(file_path).as_posix()) as file:
        return file.read()


def find_resources_packages(resources_folder: str, excluded_packages: list[str]) -> list[str]:
    return [pkg for pkg in find_namespace_packages(where=resources_folder) if pkg not in excluded_packages]


def to_packages_dir(folder_path: str, packages: list[str]) -> dict[str, str]:
    return {pkg: Path(folder_path).joinpath(pkg.replace('.', '/')).as_posix() for pkg in packages}


def clean_command_cls_factory(build_path: str, dist_path: str) -> Type[Command]:
    class CleanCmd(CleanCommand):
        def __init__(self, dist, **kw):
            super().__init__(build_path, dist_path, dist, **kw)

    return CleanCmd


def test_command_cls_factory(test_src_folder: str, test_file_pattern: str) -> Type[Command]:
    class TestCmd(TestCommand):
        def __init__(self, dist, **kw):
            super().__init__(test_src_folder, test_file_pattern, dist, **kw)

    return TestCmd


# SETUP CLASSES
# - COMMAND CLASSES
# -- Test command
class TestCommand(Command):
    """Run all unittest in `src/test/python` by using the configured `test_file_pattern` (default: `*[Tt]est*.py`)"""

    description = \
        "Run all unittest in 'src/test/python' by using the configured `test_file_pattern` (default: '*[Tt]est*.py')"

    user_options = []

    def __init__(self, test_src_folder: str, test_file_pattern: str, dist, **kw):
        self.__test_src_folder: Final[Path] = Path(test_src_folder)
        self.__test_file_pattern: Final[str] = test_file_pattern
        super().__init__(dist, **kw)

    def initialize_options(self):
        pass

    def finalize_options(self):
        pass

    def run(self):
        # Prepare tests
        test_suite: TestSuite = self._discover()

        # - Workaround for namespace package (See: https://bugs.python.org/issue23882)
        self._add_namespace_pkg_tests_workaround(test_suite)

        # Run tests
        test_result = TextTestRunner().run(test_suite)

        if not test_result.wasSuccessful():
            raise DistutilsError('Test failed: %s' % test_result)

    def _discover(self, pkg_path: Path = None) -> TestSuite:
        test_dir: str = (pkg_path or self.__test_src_folder).as_posix()
        return defaultTestLoader.discover(start_dir=test_dir, top_level_dir=test_dir, pattern=self.__test_file_pattern)

    def _add_namespace_pkg_tests_workaround(self, default_test_suite: TestSuite) -> None:
        """Workaround for namespace package (See: https://bugs.python.org/issue23882)"""
        for pkg in find_namespace_packages(self.__test_src_folder):
            pkg_path: Path = self.__test_src_folder.joinpath(pkg.replace('.', '/'))
            if not pkg_path.joinpath('__init__.py').is_file():
                self._namespace_pkg_workaround_version_warning(pkg)
                namespace_suite: TestSuite = self._discover(pkg_path)
                if namespace_suite.countTestCases() > 0:
                    default_test_suite.addTests(namespace_suite)

    @staticmethod
    def _namespace_pkg_workaround_version_warning(namespace_package: str) -> None:
        version = py_version.split('.')
        if version:
            major: Final[int] = int(version[0])
            minor: Final[int] = int(version[1]) if len(version) > 1 else 0
            # Should be fixed in python 3.11
            if major > 3 or (major == 3 and minor >= 11):
                msg: Final[str] = "WARNING: Your python version is >= 3.11. So your tests in your namespace package" \
                                  f" '{namespace_package}' will probably run twice\n" \
                                  "   This is due to an issue that should be fixed in python 3.11." \
                                  " In this case it means issue https://bugs.python.org/issue23882 is fixed" \
                                  " and you can remove the _add_namespace_pkg_tests_workaround method from" \
                                  " TestCommand class in setup.py file"
                print(msg, file=sys_stderr)


# -- Clean command
class CleanCommand(Command):
    """Remove directories generated by the 'build' command"""
    EGG_INFO_PATTERN: Final[str] = '*.egg-info'

    description = "Remove directories generated by the 'build' command"

    user_options = [
        ('build', 'b', "Remove the 'build' directory"),
        ('dist', 'd', "Remove the 'dist' directory"),
        ('egg-info', 'e', "Remove the '.egg-info' directory"),
        ('all', 'a', '(default) remove all directories')
    ]

    def __init__(self, build_path: str, dist_path: str, dist, **kw):
        self.__build_path: Final[Path] = Path(build_path)
        self.__dist_path: Final[Path] = Path(dist_path)
        self.build: bool = False
        self.dist: bool = False
        self.egg_info: bool = False
        self.all: bool = False
        super().__init__(dist, **kw)

    def initialize_options(self):
        self.build: bool = False
        self.dist: bool = False
        self.egg_info: bool = False
        self.all: bool = False

    def finalize_options(self):
        # Default action is ALL
        if not (self.build or self.dist or self.egg_info or self.all):
            self.all = True

        if self.all:
            self.build = self.dist = self.egg_info = True

    def run(self):
        print("Running clean command...")
        if self.build:
            CleanCommand._rmdir_if_exists(self.__build_path)

        if self.dist:
            CleanCommand._rmdir_if_exists(self.__dist_path)

        if self.egg_info:
            for path in Path('.').rglob(self.EGG_INFO_PATTERN):
                CleanCommand._rmdir_if_exists(path)

        print("Clean command done")

    @staticmethod
    def _rmdir_if_exists(dir_path: Path) -> None:
        if dir_path.is_dir():
            print(" |- Remove %s directory" % dir_path)
            rmtree(dir_path)


# -- Exec command
class RunCommand(Command):
    """
    Run a python module which can be in the Maven Standard Directory Layout tree without having to configure the
    PYTHONPATH
    """

    description = "Run a python module which can be in the Maven Standard Directory Layout tree without having to " \
                  + "configure the PYTHONPATH"

    user_options = [
        ('module=', 'm', "Module to run (format: '<pkg_name>.<module_name>')"),
        ('path=', 'p', "Module path to run from the command CWD if not absolute (format: 'my/path/to/the/module.py')"),
        ('args=', 'a', "Arguments of the module to run (format: '\"arg1=v1 -arg2 --arg3= v3\"')")
    ]

    def __init__(self, dist, **kw):
        self.module: str | None = None
        self.path: str | None = None
        self.args: str | None = None
        self.args_list: list[str] | None = None
        super().__init__(dist, **kw)

    def initialize_options(self):
        self.module = None
        self.path = None
        self.args = None
        self.args_list = [sys_argv[0]]

    def finalize_options(self):
        if not (self.module or self.path):
            raise OptionError("You must specify a module to run see --help")

        if self.module and self.path:
            raise OptionError("You cannot use --module= (/-m) and --path (-p) options together")

        if self.args:
            self.args_list.extend(self.args.split(" "))

    def run(self):
        argv: Final[list[str]] = sys_argv.copy()
        try:
            sys_argv.clear()
            sys_argv.extend(self.args_list)
            if self.module:
                run_module(self.module, run_name='__main__', alter_sys=True)
            else:
                run_path(self.path, run_name='__main__')
        except Exception as e:
            raise DistutilsError(e)
        finally:
            sys_argv.clear()
            sys_argv.extend(argv)


# SETUP MAIN
if __name__ == '__main__':
    # Configure sys.path for commands execution  (not necessary since PYTHONPATH is setted from project.py)
    # for project_path in project_properties.get_sources_and_resources_paths():
    #     sys_path.insert(0, project_path)

    # Sources and resources packages & package_dir configuration
    src_packages: Final[list[str]] = find_namespace_packages(where=project_properties.sources_path)
    rsrc_packages: Final[list[str]] = find_resources_packages(project_properties.resources_path, src_packages)
    #   --> {'': SRC_FOLDER} workaround for pip install -e but resources & tests will not work
    #   --> see: https://github.com/pypa/setuptools/issues/230
    src_packages_dir: Final[dict[str, str]] = {'': project_properties.sources_path}
    resources_packages_dir: Final[dict[str, str]] = to_packages_dir(project_properties.resources_path, rsrc_packages)

    # Execute setup
    setup(
        name=project_properties.name,
        version=project_properties.version,
        author=project_properties.author,
        url=project_properties.url,
        author_email=project_properties.author_email,
        description=project_properties.description,
        long_description=read_file(project_properties.long_description_file),
        long_description_content_type=project_properties.long_description_content_type,
        license=project_properties.license,
        packages=src_packages + rsrc_packages,
        package_dir=dict(resources_packages_dir, **src_packages_dir),
        package_data={'': ['*']},
        include_package_data=True,
        install_requires=project_properties.install_requires,
        entry_points=project_properties.entry_points,
        cmdclass={
            'clean': clean_command_cls_factory(project_properties.build_path, project_properties.dist_path),
            'run': RunCommand,
            'test': test_command_cls_factory(project_properties.test_sources_path, project_properties.test_file_pattern)
        },
        options={
            'build': {'build_base': project_properties.build_path},
            'bdist_wheel': {
                'bdist_dir': Path(project_properties.build_path).joinpath('wheel').as_posix(),
                'dist_dir': project_properties.dist_path
            },
            'sdist': {'dist_dir': project_properties.dist_path}
        }
    )
